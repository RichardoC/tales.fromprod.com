<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav ul li a { background-image: none; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Failing to record audio with a Tildagon ESP32 | Tales from Prod</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="Failing to record audio with a Tildagon ESP32" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Failing to record audio with a Tildagon ESP32" /> <meta property="og:description" content="Failing to record audio with a Tildagon ESP32" /> <link rel="canonical" href="https://tales.fromprod.com/2024/266/esp32-failed-audio-recorder.html" /> <meta property="og:url" content="https://tales.fromprod.com/2024/266/esp32-failed-audio-recorder.html" /> <meta property="og:site_name" content="Tales from Prod" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2024-09-22T15:00:00+00:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Failing to record audio with a Tildagon ESP32" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-22T15:00:00+00:00","datePublished":"2024-09-22T15:00:00+00:00","description":"Failing to record audio with a Tildagon ESP32","headline":"Failing to record audio with a Tildagon ESP32","mainEntityOfPage":{"@type":"WebPage","@id":"https://tales.fromprod.com/2024/266/esp32-failed-audio-recorder.html"},"url":"https://tales.fromprod.com/2024/266/esp32-failed-audio-recorder.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> Tales from Prod </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/about/" class="nav-list-link">About</a></li><li class="nav-list-item"><a href="/" class="nav-list-link">Archive</a></li><li class="nav-list-item"><a href="/categories/" class="nav-list-link">Categories</a></li><li class="nav-list-item"><a href="/useful-resources.html" class="nav-list-link">Useful resources</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Tales from Prod" aria-label="Search Tales from Prod" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="failing-to-record-audio-with-a-tildagon-esp32"> <a href="#failing-to-record-audio-with-a-tildagon-esp32" class="anchor-heading" aria-labelledby="failing-to-record-audio-with-a-tildagon-esp32"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Failing to record audio with a Tildagon ESP32 </h1> <p>The <a href="https://tildagon.badge.emfcamp.org/">Tildagon</a> ESP32 badge contains an <a href="https://tildagon.badge.emfcamp.org/tildagon-apps/reference/badge-hardware/#imu">inertial measurement unit</a> which can measure acceleration. Since sound waves will move everything (at least a little bit) can we use this accelerometer to record audio?</p> <p>No, but we can learn its limits</p> <details> <summary>Caveats</summary> * All this code was written by ChatGPT (specifically o1-preview-2024-09-12) with manual supervision. - This code is not optimised for speed or correctness, so it could be possible to record audio, just unlikely. </details> <h2 id="recording-the-data"> <a href="#recording-the-data" class="anchor-heading" aria-labelledby="recording-the-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Recording the data </h2> <p>These scripts can be run on a connected tildagon by using <a href="https://docs.micropython.org/en/latest/reference/mpremote.html">mpremote</a></p> <p>You would then run these using <code class="language-plaintext highlighter-rouge">mpremote run WHATEVER-SCRIPT-SAVED-AS.py</code></p> <details> <summary>Nice version with logging to see what's happening</summary> ```python import time import imu # Configuration parameters DURATION = 10 # Recording duration in seconds SAMPLE_RATE = 100000 # Samples per second (Hz) BUFFER_SIZE = 100 # Number of samples to buffer before writing to disk FILE_NAME = 'accelerometer_audio.txt' # Output file name def record_accelerometer(duration, sample_rate, file_name): sample_interval = 1000000 // sample_rate # Sample interval in microseconds data_buffer = [] sample_count = 0 # Initialize sample counter previous_time = None # To store the timestamp of the previous sample with open(file_name, 'w') as f: start_time = time.ticks_us() end_time = start_time + duration * 1000000 # Convert duration to microseconds next_sample_time = start_time print('Starting accelerometer recording...') while time.ticks_diff(time.ticks_us(), end_time) &lt; 0: current_time = time.ticks_us() # if time.ticks_diff(current_time, next_sample_time) &gt;= 0: if True: # Read accelerometer data x, y, z = imu.acc_read() sample_count += 1 # Increment sample counter # Calculate delta time between samples if previous_time is not None: delta_time = time.ticks_diff(current_time, previous_time) else: delta_time = 0 # For the first sample previous_time = current_time # Update previous_time # Append data to buffer with timestamp data_line = '{},{},{},{}\n'.format(current_time, x, y, z) data_buffer.append(data_line) # Logging: Print the sample number, delta time, and data # print('Sample {}: Δt={}us, Time={}, x={:.3f}, y={:.3f}, z={:.3f}'.format( # sample_count, delta_time, current_time, x, y, z)) # Schedule next sample time next_sample_time += sample_interval # If buffer is full, write to file if len(data_buffer) &gt;= BUFFER_SIZE: for line in data_buffer: f.write(line) data_buffer = [] # else: # # Sleep briefly to yield control # time.sleep_ms(1) # Write any remaining data if data_buffer: for line in data_buffer: f.write(line) print('Recording complete. Total samples recorded: {}'.format(sample_count)) # Start recording record_accelerometer(DURATION, SAMPLE_RATE, FILE_NAME) ``` </details> <details> <summary>Faster version with no nice logging</summary> ```python import time import imu # Configuration parameters DURATION = 10 # Recording duration in seconds BUFFER_SIZE = 5000 # Number of samples to buffer before writing to disk FILE_NAME = 'accelerometer_audio.txt' # Output file name def record_accelerometer(duration, file_name): sample_count = 0 # Initialize sample counter # Open the file in binary mode to speed up writing with open(file_name, 'wb') as f: start_time = time.ticks_us() end_time = start_time + duration * 1_000_000 # Convert duration to microseconds # Pre-allocate the buffer data_buffer = [''] * BUFFER_SIZE while time.ticks_diff(time.ticks_us(), end_time) &lt; 0: current_time = time.ticks_us() # Read accelerometer data x, y, z = imu.acc_read() sample_count += 1 # Increment sample counter # Prepare data line data_line = '{},{},{},{}\n'.format(current_time, x, y, z) index = (sample_count - 1) % BUFFER_SIZE data_buffer[index] = data_line # If buffer is full, write to file if index == BUFFER_SIZE - 1: f.write(''.join(data_buffer).encode('utf-8')) # Write any remaining data remaining_samples = sample_count % BUFFER_SIZE if remaining_samples &gt; 0: f.write(''.join(data_buffer[:remaining_samples]).encode('utf-8')) print('Recording complete. Total samples recorded:', sample_count) # Start recording record_accelerometer(DURATION, FILE_NAME) ``` </details> <p>The data will be saved as <code class="language-plaintext highlighter-rouge">accelerometer_audio.txt</code> on the root of the device.</p> <h2 id="recovering-the-data"> <a href="#recovering-the-data" class="anchor-heading" aria-labelledby="recovering-the-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Recovering the data </h2> <p>The following command will copy the recorded data off the device to your current working directory</p> <div class="language-console highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">mpremote cp :accelerometer_audio.txt .
</span></code></pre></div></div> <h2 id="analysing-the-data"> <a href="#analysing-the-data" class="anchor-heading" aria-labelledby="analysing-the-data"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Analysing the data </h2> <p>If you use the script below, it’ll convert the raw acceleration data in to velocity and attempt to use that as an audio signal. It’ll write this out as <code class="language-plaintext highlighter-rouge">output_audio.wav</code> which you can then listen to, and admire the thumps.</p> <details> <summary>Analysis script which displays amplitude and frequency data</summary> To use this, first install some modules using `pip3 install numpy scipy matplotlib` Then run the script from the directory where you downloaded the `accelerometer_audio.txt` file. ```python import numpy as np from scipy.io import wavfile import matplotlib.pyplot as plt from scipy.interpolate import interp1d def accelerometer_to_sound_with_integration(file_name, output_wav='output_audio.wav'): # Read accelerometer data from file timestamps = [] x_values = [] y_values = [] z_values = [] with open(file_name, 'r') as f: for line in f: # Each line is formatted as: timestamp,x,y,z parts = line.strip().split(',') if len(parts) == 4: timestamp_str, x_str, y_str, z_str = parts try: timestamp = int(timestamp_str) x = float(x_str) y = float(y_str) z = float(z_str) timestamps.append(timestamp) x_values.append(x) y_values.append(y) z_values.append(z) except ValueError: # Handle lines with invalid data continue # Convert lists to numpy arrays timestamps = np.array(timestamps) x_values = np.array(x_values) y_values = np.array(y_values) z_values = np.array(z_values) # Convert timestamps from microseconds to seconds timestamps = (timestamps - timestamps[0]) / 1e6 # Start from zero # Calculate the total duration and actual sampling rate total_duration = timestamps[-1] - timestamps[0] num_samples = len(timestamps) actual_sample_rate = num_samples / total_duration if total_duration &gt; 0 else 1 # Samples per second print(f"Total duration: {total_duration:.3f} seconds") print(f"Number of samples: {num_samples}") print(f"Actual average sample rate: {actual_sample_rate:.2f} Hz") # Subtract the mean (DC offset) from each axis to remove gravity x_mean = np.mean(x_values) y_mean = np.mean(y_values) z_mean = np.mean(z_values) x_values_zeroed = x_values - x_mean y_values_zeroed = y_values - y_mean z_values_zeroed = z_values - z_mean # Compute the magnitude of the acceleration vector at each time point acceleration_magnitude = np.sqrt(x_values_zeroed**2 + y_values_zeroed**2 + z_values_zeroed**2) # Remove any residual DC offset from acceleration magnitude acceleration_magnitude -= np.mean(acceleration_magnitude) # Create an interpolation function to resample the acceleration at a uniform rate target_sample_rate = int(actual_sample_rate) # Create new time vector with uniform sampling uniform_timestamps = np.linspace(timestamps[0], timestamps[-1], int(total_duration * target_sample_rate)) # Interpolate the acceleration onto the uniform time grid interpolation_function = interp1d(timestamps, acceleration_magnitude, kind='linear', fill_value='extrapolate') resampled_acceleration = interpolation_function(uniform_timestamps) # Integrate acceleration to obtain velocity # Use cumulative trapezoidal integration from scipy.integrate import cumulative_trapezoid velocity = cumulative_trapezoid(resampled_acceleration, uniform_timestamps, initial=0) # Remove any linear trend (drift) from the velocity signal from scipy.signal import detrend velocity_detrended = detrend(velocity) # Optional: Apply a high-pass filter to remove low-frequency noise from scipy.signal import butter, filtfilt def highpass_filter(data, cutoff=20, fs=target_sample_rate, order=5): nyq = 0.5 * fs # Nyquist Frequency normal_cutoff = cutoff / nyq # Get the filter coefficients b, a = butter(order, normal_cutoff, btype='high', analog=False) y = filtfilt(b, a, data) return y # Apply high-pass filter to remove frequencies below 20 Hz filtered_signal = highpass_filter(velocity_detrended, cutoff=20) # Normalize the signal to the int16 range (-32768 to 32767) max_abs_value = np.max(np.abs(filtered_signal)) if max_abs_value == 0: max_abs_value = 1 # Prevent division by zero normalized_signal = filtered_signal / max_abs_value # Now between -1 and 1 audio_signal = np.int16(normalized_signal * 32767) # Save the audio signal as a WAV file wavfile.write(output_wav, target_sample_rate, audio_signal) print(f"Audio file '{output_wav}' has been created with duration {total_duration:.3f} seconds.") # Plot the time-domain signal plt.figure(figsize=(12, 4)) plt.plot(uniform_timestamps, normalized_signal) plt.title('Normalized Velocity Signal (Integrated from Acceleration)') plt.xlabel('Time (s)') plt.ylabel('Amplitude') plt.show() # Compute the FFT of the signal fft_result = np.fft.fft(filtered_signal) fft_freqs = np.fft.fftfreq(len(filtered_signal), d=1.0 / target_sample_rate) # Only keep the positive frequencies positive_freqs = fft_freqs[:len(fft_freqs)//2] positive_magnitudes = np.abs(fft_result[:len(fft_result)//2]) # Plot the frequency spectrum plt.figure(figsize=(12, 6)) plt.plot(positive_freqs, positive_magnitudes) plt.title('Frequency Spectrum of the Velocity Signal') plt.xlabel('Frequency (Hz)') plt.ylabel('Magnitude') plt.xlim(0, target_sample_rate / 2) # Limit x-axis to Nyquist frequency plt.grid(True) plt.show() # Optionally, plot the spectrum on a logarithmic scale plt.figure(figsize=(12, 6)) plt.semilogy(positive_freqs, positive_magnitudes) plt.title('Frequency Spectrum of the Velocity Signal (Log Scale)') plt.xlabel('Frequency (Hz)') plt.ylabel('Magnitude (Log Scale)') plt.xlim(0, target_sample_rate / 2) plt.grid(True, which='both', linestyle='-', color='grey') plt.show() # Example usage accelerometer_to_sound_with_integration('accelerometer_audio.txt', output_wav='output_audio.wav') ``` </details> <h2 id="what-does-the-analysed-data-mean"> <a href="#what-does-the-analysed-data-mean" class="anchor-heading" aria-labelledby="what-does-the-analysed-data-mean"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> What does the analysed data mean </h2> <p>If you firmly tapped on the device during recording, you should be able to hear those taps, in a weird low quality audio recording way.</p> <h3 id="normalized-velocity-signal"> <a href="#normalized-velocity-signal" class="anchor-heading" aria-labelledby="normalized-velocity-signal"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Normalized Velocity Signal </h3> <p>You should be able to see any movement/firm bumps you gave to the device during recording here. The size of the bump should correspond to how “loud” the sound is at that part of the recording.</p> <h3 id="frequency-spectrum-of-the-velocity-signal"> <a href="#frequency-spectrum-of-the-velocity-signal" class="anchor-heading" aria-labelledby="frequency-spectrum-of-the-velocity-signal"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Frequency Spectrum of the Velocity Signal </h3> <p>This is showing the frequencies present in the audio signal, for this test there’s a peak at ~ 30Hz, with various other peaks which reduce rapidly above 50Hz.</p> <p><img src="/static/2024-09-22-esp32-failed-audio-recorder/Frequency-Spectrum.png" alt="A frequency diagram showing a peak at approximately 30Hz, with various other speaks tapering off rapidly above 60Hz" width="720" /></p> <p>I interpret this as the accelerometer (and my recording script) having a decreasing sensitivity as the frequency increases, and almost no sensitivity above 60Hz.</p> <p>Given human speech typically falls in the <a href="https://en.wikipedia.org/wiki/Voice_frequency">range 90 - 255Hz</a> this “recorder” won’t be able to capture speech.</p> <p>This is further confirmed by the fact the device <a href="https://www.bosch-sensortec.com/products/motion-sensors/imus/bmi270/">itself</a> supports a maximum accelerometer polling rate of 1.6kHz, this means the maximum audio frequency we <a href="https://en.wikipedia.org/wiki/Nyquist%E2%80%93Shannon_sampling_theorem"><em>could</em></a> record would be 800Hz.</p> <h2 id="conclusions"> <a href="#conclusions" class="anchor-heading" aria-labelledby="conclusions"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Conclusions </h2> <p>The low sampling rate (~ 1kHz) and low sensitivity to typical speech frequencies mean this isn’t a practical device to use as microphone. This still could have some uses, such as recording the frequency of dancers jumping at the club <a href="https://wiki.emfcamp.org/2024/wiki/Null_Sector">Null Sector</a> to compare this to the tempo of the songs being played from worn Tildagons.</p> </main> <hr> <footer> <p class="text-small text-grey-dk-100 mb-0">Copyright &copy; 2024 Richard Finlay Tweed. All rights reserved. All views expressed are my own</p> </footer> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
